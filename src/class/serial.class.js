const SerialPort=require("serialport"),Readline=require("@serialport/parser-readline"),InterByteTimeout=require("@serialport/parser-inter-byte-timeout"),EventEmitter=require("events");function determineData(data){return Array.isArray(data)?Buffer.from(data):Number.isInteger(data)?Buffer.from([data]):void 0===data||null===data||!1===data?Buffer.from([0]):!0===data?Buffer.from([1]):String(data)}function sleep(ms){return new Promise(resolve=>setTimeout(resolve,ms))}class serial extends EventEmitter{constructor(config,debug=!1){super();this.conf=config,this.conf.autoreconnect=null==this.conf.autoreconnect||this.conf.autoreconnect,this.conf.autoopen=null==this.conf.autoopen||this.conf.autoopen,this.reconnectInterval=this.conf.reconnectInterval||3e3,this.debug=debug,this.isOpen=!1,this.conf.autoopen&&this.connect()}softReset(baudRate=1200){const self=this;return new Promise(async(resolve,reject)=>{try{const leonardo=new SerialPort(self.conf.port,{baudRate:baudRate});return leonardo.on("error",async error=>(await sleep(100),resolve(self.softReset()))),await sleep(100),leonardo.close(),await sleep(100),resolve(!0)}catch(error){return resolve(self.softReset())}})}write(data,encoding="utf8"){const self=this;return new Promise((resolve,reject)=>{data=determineData(data),self.port.write(data,encoding,error=>{if(error)return self.debug&&console.error("serial write error : ",error),self.emit("error",error),void resolve(!1);"verbose"!=self.debug&&2!=self.debug||console.log("serial write data: ",data),resolve(!0)})})}print(msg){return this.write(msg)}println(msg){return this.print(msg+"\n")}_registerListeners(){const self=this;if(self.port.on("close",()=>{self.isOpen=!1,!0===self.conf.autoreconnect&&setTimeout(async()=>{self.debug&&console.error(`Attempting to reconnect ${self.conf.port}[${self.conf.baud}bps]...`),await self.connect()},self.reconnectInterval),self.emit("close",self.conf.port+" is closed")}),self.port.on("error",error=>{self.emit("error",error)}),self.port.on("open",()=>{self.isOpen=!0,self.emit("open","Connected to:"+self.conf.port+" baudrate:"+self.conf.baud+"bps")}),self.conf.parser&&"InterByteTimeout"===self.conf.parser.type){const interval=self.conf.parser&&self.conf.parser.interval?self.conf.parser.interval:30;self.port.pipe(new InterByteTimeout({interval:interval})).on("data",received=>{self.emit("data",received)})}else{const delimiter=self.conf.parser&&self.conf.parser.delimiter?self.conf.parser.delimiter:"\n";self.port.pipe(new Readline(delimiter)).on("data",data=>{let response={};data=data.trim();try{response={status:!0,data:JSON.parse(data)}}catch(err){response={status:!0,data:data,ascii:Buffer.from(data)}}(response.data||Number.isInteger(response.data))&&self.emit("data",response)})}}async connect(){const self=this;return self.conf.softReset&&(await self.softReset(),self.conf.softReset=!1),new Promise((resolve,reject)=>{self.port=new SerialPort(self.conf.port,{baudRate:parseInt(self.conf.baud)},function(error){if(error)return self.debug&&self.emit("error",error),void(!0===self.conf.autoreconnect?setTimeout(()=>{self.debug&&console.error(`Attempting to reconnect ${self.conf.port}[${self.conf.baud}bps]...`),resolve(self.connect())},self.reconnectInterval):reject(error));resolve(!0)}),self._registerListeners()})}}module.exports=serial;